import os.path

from pydantic import BaseModel, Field
from typing import Dict, List, Literal, Union
from . import version
import textwrap

from . import configuration as cfg
from .volumes import BaseVolume
from .containers import ContainerSpec
from ..utils import generate_uid

class ApptainerCmdBuilder(BaseModel, extra='forbid'):
    uid: str = Field(
        default_factory=generate_uid,
        description="Unique identifier for the set of containers",
    )

    containers: List[ContainerSpec] = Field(
        description="List of containers representing processes at initialization"
    )

    init_containers: List[ContainerSpec] = Field(
        default=[],
        description="List of containers representing processes to be executed simultaneously"
    )

    additional_volumes: List[BaseVolume] = Field(
        default=[],
        description="List of volumes to be mounted or binded to the apptainer container"
    )

    scratch_area: str = Field(
        default=cfg.SCRATCH_AREA,
        description="Directory to be used for temporary data related to this container set",
    )

    description: str = Field(
        default="",
        description="User-defined description of the job"
    )

    cachedir: str = Field(
        default=cfg.APPTAINER_CACHEDIR,
        description="Scratch area to store apptainer images"
    )

    @property
    def volumes(self) -> List[BaseVolume]:
        return list(set([vb.volume for c in self.containers for vb in c.volume_binds] + self.additional_volumes))

    @property
    def workdir(self):
        return os.path.join(self.scratch_area, f".acb.jobset.{self.uid}")

    def build_environment_files(self):
        return '\n'.join([container.initialize() for container in self.init_containers + self.containers])

    def exec_init_containers(self):
        return '\n'.join([container.exec() for container in self.init_containers])

    def exec_containers(self):
        ret = [
            "pid=()",
        ]

        for i_container, container in enumerate(self.containers):
            ret += [
                container.exec() + " &",
                f"pids[{i_container}]=$!",
            ]

        ret += ["wait ${pids[*]}"]

        ret += [
            f"echo '=== Output of container {container.uid} ==='\ncat {container.log_path}"
            for container in self.containers
        ]
        return '\n'.join(ret)

    def cleanup_environment_files(self):
        return '\n'.join([container.finalize() for container in self.init_containers + self.container])

    def build_volume_files(self):
        return '\n'.join([volume.initialize() for volume in self.volumes])

    def cleanup_volume_files(self):
        return '\n'.join([volume.finalize() for volume in self.volumes])

    def dump(self):
        script = textwrap.dedent("""
        #!/bin/sh
        
        ################################################################################
        ## Code generated by ApptainerCmdBuilder version %(version)s
        %(docs)s
        
        rm -rf %(workdir)s
        mkdir -p %(workdir)s
        cd %(workdir)s
        
        export APPTAINER_CACHEDIR=%(apptainer_cachedir)s
        export SINGULARITY_CACHEDIR=$APPTAINER_CACHEDIR
        mkdir -p $APPTAINER_CACHEDIR
        
        ################################################################################
        ## Environment variables
        %(environment_files)s
        
        ################################################################################
        ## Volumes settings
        %(volume_files)s
        
        ################################################################################
        ## Initialization section
        %(exec_init_containers)s
        
        ################################################################################
        ## Execution section
        %(exec_containers)s
        
        ################################################################################
        ## Clean-up section
        %(cleanup_volumes)s
        
        cd - 
        rm -rf %(workdir)s
        """) % dict(
            version=version,
            docs=''.join(["## " + line for line in self.description.splitlines()]),
            workdir=self.workdir,
            apptainer_cachedir=cfg.APPTAINER_CACHEDIR,
            environment_files=self.build_environment_files(),
            volume_files=self.build_volume_files(),
            exec_init_containers=self.exec_init_containers(),
            exec_containers=self.exec_containers(),
            cleanup_volumes=self.cleanup_volume_files(),
        )

        script_lines = script.split('\n')
        script_lines = [
            next_line
            for line, next_line in zip(script_lines[:-1], script_lines[1:])
            if len(line) + len(next_line)
        ]

        return '\n'.join(script_lines)

